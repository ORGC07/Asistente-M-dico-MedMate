{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/erick/OneDrive/Documentos/GitHub/Asistente-M-dico-MedMate/MedMate/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { WebPlugin } from '@capacitor/core';\nexport class LocalNotificationsWeb extends WebPlugin {\n  constructor() {\n    super(...arguments);\n    this.pending = [];\n    this.deliveredNotifications = [];\n    this.hasNotificationSupport = () => {\n      if (!('Notification' in window) || !Notification.requestPermission) {\n        return false;\n      }\n      if (Notification.permission !== 'granted') {\n        // don't test for `new Notification` if permission has already been granted\n        // otherwise this sends a real notification on supported browsers\n        try {\n          new Notification('');\n        } catch (e) {\n          if (e.name == 'TypeError') {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n  }\n  getDeliveredNotifications() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const deliveredSchemas = [];\n      for (const notification of _this.deliveredNotifications) {\n        const deliveredSchema = {\n          title: notification.title,\n          id: parseInt(notification.tag),\n          body: notification.body\n        };\n        deliveredSchemas.push(deliveredSchema);\n      }\n      return {\n        notifications: deliveredSchemas\n      };\n    })();\n  }\n  removeDeliveredNotifications(delivered) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      for (const toRemove of delivered.notifications) {\n        const found = _this2.deliveredNotifications.find(n => n.tag === String(toRemove.id));\n        found === null || found === void 0 ? void 0 : found.close();\n        _this2.deliveredNotifications = _this2.deliveredNotifications.filter(() => !found);\n      }\n    })();\n  }\n  removeAllDeliveredNotifications() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      for (const notification of _this3.deliveredNotifications) {\n        notification.close();\n      }\n      _this3.deliveredNotifications = [];\n    })();\n  }\n  createChannel() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      throw _this4.unimplemented('Not implemented on web.');\n    })();\n  }\n  deleteChannel() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      throw _this5.unimplemented('Not implemented on web.');\n    })();\n  }\n  listChannels() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      throw _this6.unimplemented('Not implemented on web.');\n    })();\n  }\n  schedule(options) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this7.hasNotificationSupport()) {\n        throw _this7.unavailable('Notifications not supported in this browser.');\n      }\n      for (const notification of options.notifications) {\n        _this7.sendNotification(notification);\n      }\n      return {\n        notifications: options.notifications.map(notification => ({\n          id: notification.id\n        }))\n      };\n    })();\n  }\n  getPending() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      return {\n        notifications: _this8.pending\n      };\n    })();\n  }\n  registerActionTypes() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      throw _this9.unimplemented('Not implemented on web.');\n    })();\n  }\n  cancel(pending) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      _this10.pending = _this10.pending.filter(notification => !pending.notifications.find(n => n.id === notification.id));\n    })();\n  }\n  areEnabled() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        display\n      } = yield _this11.checkPermissions();\n      return {\n        value: display === 'granted'\n      };\n    })();\n  }\n  requestPermissions() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this12.hasNotificationSupport()) {\n        throw _this12.unavailable('Notifications not supported in this browser.');\n      }\n      const display = _this12.transformNotificationPermission(yield Notification.requestPermission());\n      return {\n        display\n      };\n    })();\n  }\n  checkPermissions() {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this13.hasNotificationSupport()) {\n        throw _this13.unavailable('Notifications not supported in this browser.');\n      }\n      const display = _this13.transformNotificationPermission(Notification.permission);\n      return {\n        display\n      };\n    })();\n  }\n  transformNotificationPermission(permission) {\n    switch (permission) {\n      case 'granted':\n        return 'granted';\n      case 'denied':\n        return 'denied';\n      default:\n        return 'prompt';\n    }\n  }\n  sendPending() {\n    var _a;\n    const toRemove = [];\n    const now = new Date().getTime();\n    for (const notification of this.pending) {\n      if (((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) && notification.schedule.at.getTime() <= now) {\n        this.buildNotification(notification);\n        toRemove.push(notification);\n      }\n    }\n    this.pending = this.pending.filter(notification => !toRemove.find(n => n === notification));\n  }\n  sendNotification(notification) {\n    var _a;\n    if ((_a = notification.schedule) === null || _a === void 0 ? void 0 : _a.at) {\n      const diff = notification.schedule.at.getTime() - new Date().getTime();\n      this.pending.push(notification);\n      setTimeout(() => {\n        this.sendPending();\n      }, diff);\n      return;\n    }\n    this.buildNotification(notification);\n  }\n  buildNotification(notification) {\n    const localNotification = new Notification(notification.title, {\n      body: notification.body,\n      tag: String(notification.id)\n    });\n    localNotification.addEventListener('click', this.onClick.bind(this, notification), false);\n    localNotification.addEventListener('show', this.onShow.bind(this, notification), false);\n    localNotification.addEventListener('close', () => {\n      this.deliveredNotifications = this.deliveredNotifications.filter(() => !this);\n    }, false);\n    this.deliveredNotifications.push(localNotification);\n    return localNotification;\n  }\n  onClick(notification) {\n    const data = {\n      actionId: 'tap',\n      notification\n    };\n    this.notifyListeners('localNotificationActionPerformed', data);\n  }\n  onShow(notification) {\n    this.notifyListeners('localNotificationReceived', notification);\n  }\n}\n//# sourceMappingURL=web.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}